#[macro_use]
extern crate rocket;

#[allow(warnings, unused)]
mod db; // this is not checked into git, because it is generated by prisma
mod game_data;
mod game_id;
mod user_id;

use dotenv::dotenv;
use rocket::config::SecretKey;
use rocket::fairing::AdHoc;
use rocket::fs::FileServer;
use rocket::http::Cookie;
use rocket::serde::json::Json;
use rocket::time::{Duration, OffsetDateTime};
use rocket::{Config, State};
use std::env;
use std::fs::read_to_string;
use std::net::Ipv4Addr;
use std::path::Path;
use std::sync::Arc;

use crate::game_data::{GameData, UploadData};
use crate::game_id::GameId;
use crate::user_id::UserId;

struct AppState {
    upload_dir: String,
    db: Arc<db::PrismaClient>,
}

#[post("/save", data = "<upload_data>", format = "application/json")]
async fn api_save(
    upload_data: Json<UploadData>,
    user_id: &UserId,
    state: &State<AppState>,
) -> std::io::Result<String> {
    let data = upload_data.into_inner();
    let game_data = GameData::from(data).save().await?;

    state
        .db
        .game()
        .create(
            db::user::id::equals(user_id.0.clone()),
            game_data.id.clone().into(),
            vec![],
        )
        .exec()
        .await
        .unwrap();

    Ok(uri!(api_get_by_id(game_data.id)).to_string())
}

#[get("/list", format = "application/json")]
async fn api_list(
    state: &State<AppState>,
    user_id: &UserId,
) -> std::io::Result<Json<Vec<GameData>>> {
    let valid_files = state
        .db
        .game()
        .find_many(vec![db::game::user_id::equals(user_id.0.to_string())])
        .exec()
        .await
        .unwrap();
    let valid_files = valid_files
        .iter()
        .map(|f| f.file_path.to_string())
        .collect::<Vec<_>>();

    // list all files in upload directory belonging to the current user
    let root = Path::new(&state.upload_dir);
    let files = root
        .read_dir()?
        .filter_map(|f| f.ok())
        .filter(|f| f.file_type().unwrap().is_file())
        .filter(|f| valid_files.contains(&f.file_name().to_string_lossy().to_string()))
        .map(|f| {
            let file_name = f.path();
            let read = read_to_string(file_name).unwrap();
            let data: GameData = serde_json::from_str(&read).unwrap();
            data
        })
        .collect::<Vec<_>>();

    Ok(Json(files))
}

#[get("/get/<id>", format = "application/json")]
async fn api_get_by_id(
    id: GameId,
    user_id: &UserId,
    state: &State<AppState>,
) -> Option<Json<GameData>> {
    let found = state
        .db
        .game()
        .find_unique(db::game::id::equals(id.clone().into()))
        .exec()
        .await
        .unwrap();

    if found.is_none() || found.unwrap().user_id != user_id.0 {
        return None;
    }
    let path = id.file_path();
    let read = read_to_string(path).unwrap();
    let data = serde_json::from_str(&read).unwrap();

    Some(Json(data))
}

#[catch(404)]
fn not_found() -> Json<&'static str> {
    Json("Not found")
}

#[launch]
async fn rocket() -> _ {
    dotenv().ok();

    let port = env::var("PORT")
        .unwrap_or("8000".to_owned())
        .parse::<_>()
        .unwrap();
    let address = env::var("HOST")
        .unwrap_or(Ipv4Addr::new(127, 0, 0, 1).to_string())
        .parse::<_>()
        .unwrap();
    let app_dir = env::var("APP_DIR").unwrap_or("/srv/app".to_owned());
    let upload_dir = env::var("UPLOAD_DIR").unwrap_or("/srv/upload".to_owned());
    let secret_key = env::var("SECRET_KEY").expect("Environment variable SECRET_KEY must be set");

    let db_client = Arc::new(
        db::new_client()
            .await
            .expect("Failed to create prisma client"),
    );

    db_client
        ._db_push()
        .accept_data_loss()
        .await
        .expect("Failed to push data schema");

    rocket::build()
        .manage(AppState {
            upload_dir,
            db: db_client,
        })
        .configure(Config {
            port,
            address,
            secret_key: SecretKey::from(secret_key.as_bytes()),
            ..Default::default()
        })
        .attach(AdHoc::on_request("set-auth-cookie", |req, _| {
            Box::pin(async move {
                let user_id = req.guard::<&UserId>().await.unwrap();
                let cookie_to_set = Cookie::build("cluedo-auth", user_id.0.clone())
                    .http_only(true)
                    .expires(OffsetDateTime::now_utc() + Duration::weeks(52))
                    .finish();

                dbg!(&cookie_to_set);

                req.cookies().add(cookie_to_set);
            })
        }))
        // .attach(AdHoc::on_shutdown("save-users", |app| {
        //     Box::pin(async move {
        //         let state = app.state::<AppState>().unwrap();
        //         let users = state.users.clone();
        //         let serialized = serde_json::to_string(&users).unwrap();
        //         let mut file = File::create(users_path).await.unwrap();
        //         file.write_all(serialized.as_bytes()).await.unwrap();
        //     })
        // }))
        .mount("/api", routes![api_save, api_list, api_get_by_id])
        .mount("/", FileServer::from(app_dir))
        .register("/", catchers![not_found])
}
